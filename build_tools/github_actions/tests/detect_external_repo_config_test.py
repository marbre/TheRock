#!/usr/bin/env python3
"""Unit tests for detect_external_repo_config.py"""

import os
import sys
import tempfile
import unittest
from pathlib import Path
from unittest.mock import patch, MagicMock, mock_open

# Add parent directory to path to import the module
sys.path.insert(0, str(Path(__file__).parent.parent))

from detect_external_repo_config import (
    get_repo_config,
    get_external_repo_path,
    import_external_repo_module,
    get_skip_patterns,
    get_test_list,
    main as detect_external_repo_config_main,
    output_github_actions_vars,
    REPO_CONFIGS,
)


class TestGetRepoConfig(unittest.TestCase):
    """Tests for get_repo_config function"""

    def test_rocm_libraries_config(self):
        """Test rocm-libraries configuration"""
        config = get_repo_config("rocm-libraries")
        self.assertEqual(
            config["cmake_source_var"], "THEROCK_ROCM_LIBRARIES_SOURCE_DIR"
        )
        self.assertEqual(config["submodule_path"], "rocm-libraries")
        self.assertEqual(config["fetch_exclusion"], "--no-include-rocm-libraries")

    def test_rocm_systems_config(self):
        """Test rocm-systems configuration"""
        config = get_repo_config("rocm-systems")
        self.assertEqual(config["cmake_source_var"], "THEROCK_ROCM_SYSTEMS_SOURCE_DIR")
        self.assertEqual(config["submodule_path"], "rocm-systems")
        self.assertEqual(config["fetch_exclusion"], "--no-include-rocm-systems")

    def test_unknown_repo_raises_error(self):
        """Test that unknown repository raises ValueError"""
        with self.assertRaises(ValueError) as context:
            get_repo_config("unknown-repo")
        self.assertIn("Unknown external repository", str(context.exception))
        self.assertIn("unknown-repo", str(context.exception))

    def test_all_repos_have_required_keys(self):
        """Test that all repo configs have required keys"""
        required_keys = {
            "cmake_source_var",
            "submodule_path",
            "fetch_exclusion",
        }
        for repo_name, config in REPO_CONFIGS.items():
            with self.subTest(repo=repo_name):
                self.assertTrue(
                    required_keys.issubset(config.keys()),
                    f"Repo {repo_name} missing required keys: {required_keys - config.keys()}",
                )


class TestOutputGithubActionsVars(unittest.TestCase):
    """Tests for output_github_actions_vars function"""

    def setUp(self):
        """Set up test fixtures"""
        # Create temporary file for GITHUB_OUTPUT
        with tempfile.NamedTemporaryFile(mode="w+", delete=False) as f:
            self.temp_file = f.name
        os.environ["GITHUB_OUTPUT"] = self.temp_file

    def tearDown(self):
        """Clean up test fixtures"""
        # Remove GITHUB_OUTPUT env var
        if "GITHUB_OUTPUT" in os.environ:
            del os.environ["GITHUB_OUTPUT"]
        # Delete temp file
        if hasattr(self, "temp_file") and os.path.exists(self.temp_file):
            os.unlink(self.temp_file)

    def test_output_to_file(self):
        """Test output to GITHUB_OUTPUT file"""
        config = {
            "cmake_source_var": "TEST_VAR",
            "submodule_path": "test-dir",
            "fetch_exclusion": "--no-include-test",
        }

        output_github_actions_vars(config)

        # Read the output file
        with open(self.temp_file, "r") as f:
            output = f.read()

        # Verify output format
        self.assertIn("cmake_source_var=TEST_VAR", output)
        self.assertIn("submodule_path=test-dir", output)
        self.assertIn("fetch_exclusion=--no-include-test", output)

    def test_boolean_conversion(self):
        """Test that booleans are converted to lowercase strings"""
        config = {
            "bool_true": True,
            "bool_false": False,
        }

        output_github_actions_vars(config)

        with open(self.temp_file, "r") as f:
            output = f.read()

        # Verify lowercase (important for bash conditionals)
        self.assertIn("bool_true=true", output)
        self.assertIn("bool_false=false", output)
        self.assertNotIn("True", output)
        self.assertNotIn("False", output)

    def test_extra_cmake_options_generated(self):
        """Test that extra_cmake_options is generated by main() when --workspace is provided."""
        rc = detect_external_repo_config_main(
            [
                "--repository",
                "rocm-libraries",
                "--workspace",
                "/workspace",
            ]
        )
        self.assertEqual(rc, 0)

        with open(self.temp_file, "r") as f:
            output = f.read()

        # Verify extra_cmake_options is included
        self.assertIn(
            "extra_cmake_options=-DTHEROCK_ROCM_LIBRARIES_SOURCE_DIR=/workspace",
            output,
        )


class TestGetExternalRepoPath(unittest.TestCase):
    """Tests for get_external_repo_path function"""

    @patch.dict(
        os.environ,
        {"EXTERNAL_SOURCE_PATH": "rocm-libraries", "GITHUB_WORKSPACE": "/workspace"},
    )
    @patch("detect_external_repo_config.Path")
    @patch("detect_external_repo_config._is_valid_repo_path")
    def test_external_source_path_priority(self, mock_is_valid, mock_path_cls):
        """Test that EXTERNAL_SOURCE_PATH has highest priority"""
        # Mock Path behavior
        mock_path = MagicMock()
        mock_path.exists.return_value = True
        mock_path.name = "rocm-libraries"
        mock_path_cls.return_value = mock_path

        # Mock validation
        mock_is_valid.return_value = True

        result = get_external_repo_path("rocm-libraries")
        self.assertIsNotNone(result)

    @patch.dict(os.environ, {}, clear=True)
    @patch("detect_external_repo_config.Path")
    @patch("detect_external_repo_config._is_valid_repo_path")
    def test_cwd_fallback(self, mock_is_valid, mock_path_cls):
        """Test that current working directory is used as fallback"""
        mock_cwd = MagicMock()
        mock_cwd.exists.return_value = True
        mock_path_cls.cwd.return_value = mock_cwd
        mock_is_valid.return_value = True

        result = get_external_repo_path("rocm-libraries")
        self.assertEqual(result, mock_cwd)

    @patch.dict(os.environ, {}, clear=True)
    @patch("detect_external_repo_config.Path")
    @patch("detect_external_repo_config._is_valid_repo_path")
    def test_no_valid_path_raises_error(self, mock_is_valid, mock_path_cls):
        """Test that ValueError is raised when no valid path is found"""
        # Clear the cache to ensure this test runs fresh
        get_external_repo_path.cache_clear()

        mock_cwd = MagicMock()
        mock_path_cls.cwd.return_value = mock_cwd
        mock_is_valid.return_value = False

        with self.assertRaises(ValueError) as context:
            get_external_repo_path("rocm-libraries")
        self.assertIn("Could not find external repo", str(context.exception))


class TestImportExternalRepoModule(unittest.TestCase):
    """Tests for import_external_repo_module function"""

    @patch("detect_external_repo_config.get_external_repo_path")
    @patch("importlib.util.spec_from_file_location")
    @patch("importlib.util.module_from_spec")
    def test_successful_import(
        self, mock_module_from_spec, mock_spec_from_file, mock_get_path
    ):
        """Test successful module import"""
        # Mock repo path
        mock_repo_path = MagicMock()
        mock_script_path = MagicMock()
        mock_script_path.exists.return_value = True
        mock_repo_path.__truediv__ = MagicMock(return_value=mock_script_path)
        mock_get_path.return_value = mock_repo_path

        # Mock importlib
        mock_spec = MagicMock()
        mock_loader = MagicMock()
        mock_spec.loader = mock_loader
        mock_module = MagicMock()
        mock_spec_from_file.return_value = mock_spec
        mock_module_from_spec.return_value = mock_module

        result = import_external_repo_module("rocm-libraries", "test_module")
        self.assertEqual(result, mock_module)
        mock_loader.exec_module.assert_called_once_with(mock_module)

    @patch("detect_external_repo_config.get_external_repo_path")
    def test_module_not_found(self, mock_get_path):
        """Test handling when module file doesn't exist"""
        mock_repo_path = MagicMock()
        mock_script_path = MagicMock()
        mock_script_path.exists.return_value = False
        mock_repo_path.__truediv__ = MagicMock(return_value=mock_script_path)
        mock_get_path.return_value = mock_repo_path

        result = import_external_repo_module("rocm-libraries", "missing_module")
        self.assertIsNone(result)

    @patch("detect_external_repo_config.get_external_repo_path")
    @patch("importlib.util.spec_from_file_location")
    @patch("importlib.util.module_from_spec")
    def test_import_error_handling(
        self, mock_module_from_spec, mock_spec_from_file, mock_get_path
    ):
        """Test handling of ImportError during module loading"""
        mock_repo_path = MagicMock()
        mock_script_path = MagicMock()
        mock_script_path.exists.return_value = True
        mock_repo_path.__truediv__ = MagicMock(return_value=mock_script_path)
        mock_get_path.return_value = mock_repo_path

        # Mock import failure
        mock_spec = MagicMock()
        mock_loader = MagicMock()
        mock_spec.loader = mock_loader
        mock_loader.exec_module.side_effect = ImportError("Import failed")
        mock_spec_from_file.return_value = mock_spec
        mock_module_from_spec.return_value = MagicMock()

        result = import_external_repo_module("rocm-libraries", "test_module")
        self.assertIsNone(result)


class TestGetSkipPatterns(unittest.TestCase):
    """Tests for get_skip_patterns function"""

    @patch("detect_external_repo_config.import_external_repo_module")
    def test_get_skip_patterns_success(self, mock_import):
        """Test successful retrieval of skip patterns"""
        mock_module = MagicMock()
        mock_module.SKIPPABLE_PATH_PATTERNS = ["pattern1/*", "pattern2/*"]
        mock_import.return_value = mock_module

        result = get_skip_patterns("rocm-libraries")
        self.assertEqual(result, ["pattern1/*", "pattern2/*"])

    @patch("detect_external_repo_config.import_external_repo_module")
    def test_get_skip_patterns_no_module(self, mock_import):
        """Test when module cannot be imported"""
        mock_import.return_value = None

        result = get_skip_patterns("rocm-libraries")
        self.assertEqual(result, [])

    @patch("detect_external_repo_config.import_external_repo_module")
    def test_get_skip_patterns_no_attribute(self, mock_import):
        """Test when module doesn't have SKIPPABLE_PATH_PATTERNS attribute"""
        mock_module = MagicMock(spec=[])
        del mock_module.SKIPPABLE_PATH_PATTERNS  # Ensure attribute doesn't exist
        mock_import.return_value = mock_module

        result = get_skip_patterns("rocm-libraries")
        self.assertEqual(result, [])


class TestGetTestList(unittest.TestCase):
    """Tests for get_test_list function"""

    @patch("detect_external_repo_config.import_external_repo_module")
    def test_get_test_list_success(self, mock_import):
        """Test successful retrieval of test list"""
        mock_module = MagicMock()
        mock_module.project_map = {
            "project1": {"project_to_test": ["test1", "test2"]},
            "project2": {"project_to_test": "test3"},
        }
        mock_import.return_value = mock_module

        result = get_test_list("rocm-libraries")
        # Result is a sorted list from a set, so order may vary
        self.assertEqual(set(result), {"test1", "test2", "test3"})

    @patch("detect_external_repo_config.import_external_repo_module")
    def test_get_test_list_no_module(self, mock_import):
        """Test when module cannot be imported"""
        mock_import.return_value = None

        result = get_test_list("rocm-libraries")
        self.assertEqual(result, [])

    @patch("detect_external_repo_config.import_external_repo_module")
    def test_get_test_list_no_attribute(self, mock_import):
        """Test when module doesn't have project_map attribute"""
        mock_module = MagicMock(spec=[])
        del mock_module.project_map  # Ensure attribute doesn't exist
        mock_import.return_value = mock_module

        result = get_test_list("rocm-libraries")
        self.assertEqual(result, [])


if __name__ == "__main__":
    unittest.main()
